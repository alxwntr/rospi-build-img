# img.subr
# Functions for manipulating image files

# img_config
# Set globals based on the config
img_config () {
    : ${image_size:=10G}

    part_boot="p1"

    if [ -n "${image_swap}" ]
    then
        part_swap="p2"
        part_root="p3"
    else
        part_swap=""
        part_root="p2"
    fi
}

# loop_start IMAGE
# Creates a loop device and prints its name
loop_start () {
    local img="$1"
    local lo=

    lo="$(losetup -f --show "$img")"
    [ $? -eq 0 ] || die "Can't setup loop device!"

    partprobe "$lo"
    echo "$lo"
}

# loop_stop DEV
# Detaches a loop device
loop_stop () {
    local lo="$1"

    losetup -d "$lo"
}

# img_create IMAGE
# Create an image file and set up the filesystems.
img_create () {
    local img="$1"

    img_create_file "$img"
    img_partition "$img"
    img_mkfs "$img"
}

# img_create_file IMAGE
# Create an image file
img_create_file () {
    local img="$1"

    say "Creating image [$img] ($size)..."
    rm -f "$img"
    truncate -s "${image_size}" "$img"
}

# img_partition IMAGE
# Set up the partition table.
img_partition () {
    local img="$1"
    local swpart=

    say "Setting up partition table..."
    [ -n "${image_swap}" ] && swpart="- ${image_swap} 82 -"

    sfdisk -q "$img" <<FDISK
label: dos
- 256M c *
$swpart
- - 83 -
FDISK
}

# img_mkfs IMAGE
# Create the filesystems.
img_mkfs () {
    local img="$1"
    local lo=

    say "Creating filesystems..."

    lo="$(loop_start "$img")"

    mkfs.vfat "${lo}${part_boot}"
    [ -n "${part_swap}" ] && mkswap "${lo}${part_swap}"
    mkfs.ext4 "${lo}${part_root}"

    # Unloop the device here. Sometimes the kernel gets upset if we don't do
    # this, and starts complaining about WRITE_ZEROS failures. (This may only
    # happen if the img is on NFS.)
    loop_stop "$lo"
}

img_devices="null zero full random urandom fd stdin stdout stderr ptmx"

# img_mount IMAGE DIR
# Mount the filesystems from IMAGE on DIR
img_mount () {
    local img="$1" dir="$2"
    local lo=

    say "Mounting filesystems on [$dir]..."

    lo="$(loop_start "$img")"

    install_dir "$dir"
    mount -t ext4 "${lo}${part_root}" "$dir"
    install_dir "$dir/boot/firmware"
    mount -t vfat "${lo}${part_boot}" "$dir/boot/firmware"

    install_dir "$dir/proc"
    mount -t proc proc "$dir/proc"
    install_dir "$dir/sys"
    mount -t sysfs sysfs "$dir/sys"

    install_dir "$dir/dev"
    mount -t tmpfs dev "$dir/dev"
    (cd /dev && cp -a $img_devices "$(realpath "$dir/dev/")")
    install_dir "$dir/dev/pts"
    mount -t devpts devpts "$dir/dev/pts"

    echo "$lo"
}

# img_umount DIR LOOP
# Unmount the image from DIR and unloop LOOP
img_umount () {
    local root="$1" lo="$2"

    say "Unmounting from [$root]..."

    safe_umount "$root/dev/pts"
    safe_umount "$root/dev"
    safe_umount "$root/sys"
    safe_umount "$root/proc"
    umount "$root/boot/firmware"
    umount "$root"
    loop_stop "$lo"
}

# img_build IMAGE
# Build and image according to the config
img_build () {
    local img="$1"
    local root="./root"
    local lo=

    [ -z "$img" ]           && die "Must specify an image filename!"
    [ -z "$dist_release" ]  && die "Must specify dist_release!"
    [ -z "$dist_mirror" ]   && die "Must specify dist_mirror!"

    [ -n "$http_proxy" ] && export http_proxy

    img_config
    pkg_config "$root"

    img_create "$img"

    lo="$(img_mount "$img" "$root")"
    pkg_bootstrap 
    img_umount "$root" "$lo"

    # Debootstrap unmounts /proc and so on, so remount.
    lo="$(img_mount "$img" "$root")"
    pkg_set_sources
    pkg_install_pkgs
    img_umount "$root" "$lo"

    say "Done."
}

# vi:set ft=sh:
